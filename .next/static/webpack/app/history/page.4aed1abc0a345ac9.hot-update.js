"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/history/page",{

/***/ "(app-pages-browser)/./hooks/useChatSessions.ts":
/*!**********************************!*\
  !*** ./hooks/useChatSessions.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChatSessions: () => (/* binding */ useChatSessions)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useChatSessions auto */ \nconst SESSIONS_STORAGE_KEY = 'lucra-ai-sessions';\nconst ACTIVE_SESSION_KEY = 'lucra-ai-active-session';\nfunction useChatSessions() {\n    const [sessions, setSessions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [activeSessionId, setActiveSessionId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    // Загрузка сессий из localStorage\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChatSessions.useEffect\": ()=>{\n            try {\n                const storedSessions = window.localStorage.getItem(SESSIONS_STORAGE_KEY);\n                const storedActiveId = window.localStorage.getItem(ACTIVE_SESSION_KEY);\n                if (storedSessions) {\n                    setSessions(JSON.parse(storedSessions));\n                }\n                if (storedActiveId) {\n                    setActiveSessionId(storedActiveId);\n                }\n            } catch (error) {\n                console.error('Error loading sessions:', error);\n            }\n            setIsLoading(false);\n        }\n    }[\"useChatSessions.useEffect\"], []);\n    // Сохранение в localStorage при изменении\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChatSessions.useEffect\": ()=>{\n            if (!isLoading) {\n                try {\n                    window.localStorage.setItem(SESSIONS_STORAGE_KEY, JSON.stringify(sessions));\n                } catch (error) {\n                    console.error('Error saving sessions:', error);\n                }\n            }\n        }\n    }[\"useChatSessions.useEffect\"], [\n        sessions,\n        isLoading\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChatSessions.useEffect\": ()=>{\n            if (!isLoading && activeSessionId) {\n                try {\n                    window.localStorage.setItem(ACTIVE_SESSION_KEY, activeSessionId);\n                } catch (error) {\n                    console.error('Error saving active session:', error);\n                }\n            }\n        }\n    }[\"useChatSessions.useEffect\"], [\n        activeSessionId,\n        isLoading\n    ]);\n    // Создание новой сессии\n    const createSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChatSessions.useCallback[createSession]\": ()=>{\n            const newSession = {\n                id: crypto.randomUUID(),\n                title: 'New Chat',\n                messages: [],\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            };\n            setSessions({\n                \"useChatSessions.useCallback[createSession]\": (prev)=>[\n                        newSession,\n                        ...prev\n                    ]\n            }[\"useChatSessions.useCallback[createSession]\"]);\n            setActiveSessionId(newSession.id);\n            return newSession;\n        }\n    }[\"useChatSessions.useCallback[createSession]\"], []);\n    // Обновление сессии (добавление сообщений)\n    const updateSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChatSessions.useCallback[updateSession]\": (sessionId, messages)=>{\n            setSessions({\n                \"useChatSessions.useCallback[updateSession]\": (prev)=>prev.map({\n                        \"useChatSessions.useCallback[updateSession]\": (session)=>{\n                            if (session.id === sessionId) {\n                                // Генерируем название из первого сообщения пользователя\n                                let title = session.title;\n                                if (title === 'New Chat' && messages.length > 0) {\n                                    const firstUserMessage = messages.find({\n                                        \"useChatSessions.useCallback[updateSession].firstUserMessage\": (m)=>m.role === 'user'\n                                    }[\"useChatSessions.useCallback[updateSession].firstUserMessage\"]);\n                                    if (firstUserMessage) {\n                                        title = firstUserMessage.text.slice(0, 50);\n                                        if (firstUserMessage.text.length > 50) {\n                                            title += '...';\n                                        }\n                                    }\n                                }\n                                return {\n                                    ...session,\n                                    title,\n                                    messages,\n                                    updatedAt: Date.now()\n                                };\n                            }\n                            return session;\n                        }\n                    }[\"useChatSessions.useCallback[updateSession]\"])\n            }[\"useChatSessions.useCallback[updateSession]\"]);\n        }\n    }[\"useChatSessions.useCallback[updateSession]\"], []);\n    // Генерация названия с помощью AI\n    const generateTitle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChatSessions.useCallback[generateTitle]\": async (sessionId, messages)=>{\n            // Устанавливаем флаг генерации\n            setSessions({\n                \"useChatSessions.useCallback[generateTitle]\": (prev)=>prev.map({\n                        \"useChatSessions.useCallback[generateTitle]\": (session)=>session.id === sessionId ? {\n                                ...session,\n                                isGeneratingTitle: true\n                            } : session\n                    }[\"useChatSessions.useCallback[generateTitle]\"])\n            }[\"useChatSessions.useCallback[generateTitle]\"]);\n            try {\n                const response = await fetch('/api/generate-title', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        messages\n                    })\n                });\n                if (!response.ok) {\n                    const errorData = await response.json();\n                    console.error('API error:', errorData);\n                    throw new Error(errorData.details || 'Failed to generate title');\n                }\n                const { title } = await response.json();\n                // Обновляем название с эффектом печатания\n                updateSessionTitle(sessionId, title);\n            } catch (error) {\n                console.error('Error generating title:', error);\n                // В случае ошибки снимаем флаг генерации\n                setSessions({\n                    \"useChatSessions.useCallback[generateTitle]\": (prev)=>prev.map({\n                            \"useChatSessions.useCallback[generateTitle]\": (session)=>session.id === sessionId ? {\n                                    ...session,\n                                    isGeneratingTitle: false\n                                } : session\n                        }[\"useChatSessions.useCallback[generateTitle]\"])\n                }[\"useChatSessions.useCallback[generateTitle]\"]);\n            }\n        }\n    }[\"useChatSessions.useCallback[generateTitle]\"], []);\n    // Обновление названия сессии с эффектом печатания\n    const updateSessionTitle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChatSessions.useCallback[updateSessionTitle]\": (sessionId, newTitle)=>{\n            setSessions({\n                \"useChatSessions.useCallback[updateSessionTitle]\": (prev)=>prev.map({\n                        \"useChatSessions.useCallback[updateSessionTitle]\": (session)=>session.id === sessionId ? {\n                                ...session,\n                                title: newTitle,\n                                isGeneratingTitle: false,\n                                titleGenerated: true\n                            } : session\n                    }[\"useChatSessions.useCallback[updateSessionTitle]\"])\n            }[\"useChatSessions.useCallback[updateSessionTitle]\"]);\n        }\n    }[\"useChatSessions.useCallback[updateSessionTitle]\"], []);\n    // Удаление сессии\n    const deleteSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChatSessions.useCallback[deleteSession]\": (sessionId)=>{\n            setSessions({\n                \"useChatSessions.useCallback[deleteSession]\": (prev)=>{\n                    const filtered = prev.filter({\n                        \"useChatSessions.useCallback[deleteSession].filtered\": (s)=>s.id !== sessionId\n                    }[\"useChatSessions.useCallback[deleteSession].filtered\"]);\n                    // Если удаляем активную сессию, переключаемся на первую из оставшихся\n                    if (sessionId === activeSessionId) {\n                        var _filtered_;\n                        const nextActive = ((_filtered_ = filtered[0]) === null || _filtered_ === void 0 ? void 0 : _filtered_.id) || null;\n                        setActiveSessionId(nextActive);\n                        if (nextActive) {\n                            window.localStorage.setItem(ACTIVE_SESSION_KEY, nextActive);\n                        } else {\n                            window.localStorage.removeItem(ACTIVE_SESSION_KEY);\n                        }\n                    }\n                    return filtered;\n                }\n            }[\"useChatSessions.useCallback[deleteSession]\"]);\n        }\n    }[\"useChatSessions.useCallback[deleteSession]\"], [\n        activeSessionId\n    ]);\n    // Установка активной сессии\n    const setActiveSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChatSessions.useCallback[setActiveSession]\": (sessionId)=>{\n            setActiveSessionId(sessionId);\n            if (sessionId) {\n                window.localStorage.setItem(ACTIVE_SESSION_KEY, sessionId);\n            } else {\n                window.localStorage.removeItem(ACTIVE_SESSION_KEY);\n            }\n        }\n    }[\"useChatSessions.useCallback[setActiveSession]\"], []);\n    // Получение активной сессии\n    const activeSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useChatSessions.useMemo[activeSession]\": ()=>{\n            return sessions.find({\n                \"useChatSessions.useMemo[activeSession]\": (s)=>s.id === activeSessionId\n            }[\"useChatSessions.useMemo[activeSession]\"]) || null;\n        }\n    }[\"useChatSessions.useMemo[activeSession]\"], [\n        sessions,\n        activeSessionId\n    ]);\n    // Группировка сессий по дате\n    const groupedSessions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useChatSessions.useMemo[groupedSessions]\": ()=>{\n            const now = new Date();\n            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();\n            const yesterday = today - 24 * 60 * 60 * 1000;\n            const weekAgo = today - 7 * 24 * 60 * 60 * 1000;\n            const groups = {\n                today: [],\n                yesterday: [],\n                thisWeek: [],\n                older: []\n            };\n            // Сортируем по дате обновления (новые сверху)\n            const sorted = [\n                ...sessions\n            ].sort({\n                \"useChatSessions.useMemo[groupedSessions].sorted\": (a, b)=>b.updatedAt - a.updatedAt\n            }[\"useChatSessions.useMemo[groupedSessions].sorted\"]);\n            sorted.forEach({\n                \"useChatSessions.useMemo[groupedSessions]\": (session)=>{\n                    const sessionDate = session.updatedAt;\n                    if (sessionDate >= today) {\n                        groups.today.push(session);\n                    } else if (sessionDate >= yesterday) {\n                        groups.yesterday.push(session);\n                    } else if (sessionDate >= weekAgo) {\n                        groups.thisWeek.push(session);\n                    } else {\n                        groups.older.push(session);\n                    }\n                }\n            }[\"useChatSessions.useMemo[groupedSessions]\"]);\n            return groups;\n        }\n    }[\"useChatSessions.useMemo[groupedSessions]\"], [\n        sessions\n    ]);\n    return {\n        sessions,\n        activeSession,\n        activeSessionId,\n        isLoading,\n        createSession,\n        updateSession,\n        deleteSession,\n        setActiveSession,\n        groupedSessions,\n        generateTitle\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUNoYXRTZXNzaW9ucy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7cUVBRWtFO0FBR2xFLE1BQU1JLHVCQUF1QjtBQUM3QixNQUFNQyxxQkFBcUI7QUFVcEIsU0FBU0M7SUFDWixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR1IsK0NBQVFBLENBQWdCLEVBQUU7SUFDMUQsTUFBTSxDQUFDUyxpQkFBaUJDLG1CQUFtQixHQUFHViwrQ0FBUUEsQ0FBZ0I7SUFDdEUsTUFBTSxDQUFDVyxXQUFXQyxhQUFhLEdBQUdaLCtDQUFRQSxDQUFDO0lBRTNDLGtDQUFrQztJQUNsQ0MsZ0RBQVNBO3FDQUFDO1lBQ04sSUFBSTtnQkFDQSxNQUFNWSxpQkFBaUJDLE9BQU9DLFlBQVksQ0FBQ0MsT0FBTyxDQUFDWjtnQkFDbkQsTUFBTWEsaUJBQWlCSCxPQUFPQyxZQUFZLENBQUNDLE9BQU8sQ0FBQ1g7Z0JBRW5ELElBQUlRLGdCQUFnQjtvQkFDaEJMLFlBQVlVLEtBQUtDLEtBQUssQ0FBQ047Z0JBQzNCO2dCQUNBLElBQUlJLGdCQUFnQjtvQkFDaEJQLG1CQUFtQk87Z0JBQ3ZCO1lBQ0osRUFBRSxPQUFPRyxPQUFPO2dCQUNaQyxRQUFRRCxLQUFLLENBQUMsMkJBQTJCQTtZQUM3QztZQUNBUixhQUFhO1FBQ2pCO29DQUFHLEVBQUU7SUFFTCwwQ0FBMEM7SUFDMUNYLGdEQUFTQTtxQ0FBQztZQUNOLElBQUksQ0FBQ1UsV0FBVztnQkFDWixJQUFJO29CQUNBRyxPQUFPQyxZQUFZLENBQUNPLE9BQU8sQ0FBQ2xCLHNCQUFzQmMsS0FBS0ssU0FBUyxDQUFDaEI7Z0JBQ3JFLEVBQUUsT0FBT2EsT0FBTztvQkFDWkMsUUFBUUQsS0FBSyxDQUFDLDBCQUEwQkE7Z0JBQzVDO1lBQ0o7UUFDSjtvQ0FBRztRQUFDYjtRQUFVSTtLQUFVO0lBRXhCVixnREFBU0E7cUNBQUM7WUFDTixJQUFJLENBQUNVLGFBQWFGLGlCQUFpQjtnQkFDL0IsSUFBSTtv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dUM7UUFDWDttREFBRztRQUFDdkU7S0FBUztJQUViLE9BQU87UUFDSEE7UUFDQThEO1FBQ0E1RDtRQUNBRTtRQUNBYTtRQUNBWTtRQUNBMEI7UUFDQU07UUFDQUU7UUFDQXZCO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsiL1VzZXJzL2R3aGl0ZXdvbGYvV29yay9NVlAvTHVjcmFBSS9ob29rcy91c2VDaGF0U2Vzc2lvbnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IENoYXRTZXNzaW9uLCBDaGF0TWVzc2FnZSB9IGZyb20gJ0AvdHlwZXMnO1xuXG5jb25zdCBTRVNTSU9OU19TVE9SQUdFX0tFWSA9ICdsdWNyYS1haS1zZXNzaW9ucyc7XG5jb25zdCBBQ1RJVkVfU0VTU0lPTl9LRVkgPSAnbHVjcmEtYWktYWN0aXZlLXNlc3Npb24nO1xuXG4vLyDQk9GA0YPQv9C/0Ysg0L/QviDQtNCw0YLQtVxuZXhwb3J0IGludGVyZmFjZSBHcm91cGVkU2Vzc2lvbnMge1xuICAgIHRvZGF5OiBDaGF0U2Vzc2lvbltdO1xuICAgIHllc3RlcmRheTogQ2hhdFNlc3Npb25bXTtcbiAgICB0aGlzV2VlazogQ2hhdFNlc3Npb25bXTtcbiAgICBvbGRlcjogQ2hhdFNlc3Npb25bXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoYXRTZXNzaW9ucygpIHtcbiAgICBjb25zdCBbc2Vzc2lvbnMsIHNldFNlc3Npb25zXSA9IHVzZVN0YXRlPENoYXRTZXNzaW9uW10+KFtdKTtcbiAgICBjb25zdCBbYWN0aXZlU2Vzc2lvbklkLCBzZXRBY3RpdmVTZXNzaW9uSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuXG4gICAgLy8g0JfQsNCz0YDRg9C30LrQsCDRgdC10YHRgdC40Lkg0LjQtyBsb2NhbFN0b3JhZ2VcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkU2Vzc2lvbnMgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oU0VTU0lPTlNfU1RPUkFHRV9LRVkpO1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkQWN0aXZlSWQgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oQUNUSVZFX1NFU1NJT05fS0VZKTtcblxuICAgICAgICAgICAgaWYgKHN0b3JlZFNlc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgc2V0U2Vzc2lvbnMoSlNPTi5wYXJzZShzdG9yZWRTZXNzaW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0b3JlZEFjdGl2ZUlkKSB7XG4gICAgICAgICAgICAgICAgc2V0QWN0aXZlU2Vzc2lvbklkKHN0b3JlZEFjdGl2ZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc2Vzc2lvbnM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfSwgW10pO1xuXG4gICAgLy8g0KHQvtGF0YDQsNC90LXQvdC40LUg0LIgbG9jYWxTdG9yYWdlINC/0YDQuCDQuNC30LzQtdC90LXQvdC40LhcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWlzTG9hZGluZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oU0VTU0lPTlNfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHNlc3Npb25zKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBzZXNzaW9uczonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbc2Vzc2lvbnMsIGlzTG9hZGluZ10pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0xvYWRpbmcgJiYgYWN0aXZlU2Vzc2lvbklkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShBQ1RJVkVfU0VTU0lPTl9LRVksIGFjdGl2ZVNlc3Npb25JZCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBhY3RpdmUgc2Vzc2lvbjonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbYWN0aXZlU2Vzc2lvbklkLCBpc0xvYWRpbmddKTtcblxuICAgIC8vINCh0L7Qt9C00LDQvdC40LUg0L3QvtCy0L7QuSDRgdC10YHRgdC40LhcbiAgICBjb25zdCBjcmVhdGVTZXNzaW9uID0gdXNlQ2FsbGJhY2soKCk6IENoYXRTZXNzaW9uID0+IHtcbiAgICAgICAgY29uc3QgbmV3U2Vzc2lvbjogQ2hhdFNlc3Npb24gPSB7XG4gICAgICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgICAgICAgIHRpdGxlOiAnTmV3IENoYXQnLFxuICAgICAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdXBkYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHNldFNlc3Npb25zKHByZXYgPT4gW25ld1Nlc3Npb24sIC4uLnByZXZdKTtcbiAgICAgICAgc2V0QWN0aXZlU2Vzc2lvbklkKG5ld1Nlc3Npb24uaWQpO1xuXG4gICAgICAgIHJldHVybiBuZXdTZXNzaW9uO1xuICAgIH0sIFtdKTtcblxuICAgIC8vINCe0LHQvdC+0LLQu9C10L3QuNC1INGB0LXRgdGB0LjQuCAo0LTQvtCx0LDQstC70LXQvdC40LUg0YHQvtC+0LHRidC10L3QuNC5KVxuICAgIGNvbnN0IHVwZGF0ZVNlc3Npb24gPSB1c2VDYWxsYmFjaygoc2Vzc2lvbklkOiBzdHJpbmcsIG1lc3NhZ2VzOiBDaGF0TWVzc2FnZVtdKSA9PiB7XG4gICAgICAgIHNldFNlc3Npb25zKHByZXYgPT4gcHJldi5tYXAoc2Vzc2lvbiA9PiB7XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi5pZCA9PT0gc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgLy8g0JPQtdC90LXRgNC40YDRg9C10Lwg0L3QsNC30LLQsNC90LjQtSDQuNC3INC/0LXRgNCy0L7Qs9C+INGB0L7QvtCx0YnQtdC90LjRjyDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y9cbiAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSBzZXNzaW9uLnRpdGxlO1xuICAgICAgICAgICAgICAgIGlmICh0aXRsZSA9PT0gJ05ldyBDaGF0JyAmJiBtZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VXNlck1lc3NhZ2UgPSBtZXNzYWdlcy5maW5kKG0gPT4gbS5yb2xlID09PSAndXNlcicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RVc2VyTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBmaXJzdFVzZXJNZXNzYWdlLnRleHQuc2xpY2UoMCwgNTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0VXNlck1lc3NhZ2UudGV4dC5sZW5ndGggPiA1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlICs9ICcuLi4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc2Vzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgICB9KSk7XG4gICAgfSwgW10pO1xuXG4gICAgLy8g0JPQtdC90LXRgNCw0YbQuNGPINC90LDQt9Cy0LDQvdC40Y8g0YEg0L/QvtC80L7RidGM0Y4gQUlcbiAgICBjb25zdCBnZW5lcmF0ZVRpdGxlID0gdXNlQ2FsbGJhY2soYXN5bmMgKHNlc3Npb25JZDogc3RyaW5nLCBtZXNzYWdlczogQ2hhdE1lc3NhZ2VbXSkgPT4ge1xuICAgICAgICAvLyDQo9GB0YLQsNC90LDQstC70LjQstCw0LXQvCDRhNC70LDQsyDQs9C10L3QtdGA0LDRhtC40LhcbiAgICAgICAgc2V0U2Vzc2lvbnMocHJldiA9PiBwcmV2Lm1hcChzZXNzaW9uID0+XG4gICAgICAgICAgICBzZXNzaW9uLmlkID09PSBzZXNzaW9uSWRcbiAgICAgICAgICAgICAgICA/IHsgLi4uc2Vzc2lvbiwgaXNHZW5lcmF0aW5nVGl0bGU6IHRydWUgfVxuICAgICAgICAgICAgICAgIDogc2Vzc2lvblxuICAgICAgICApKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9nZW5lcmF0ZS10aXRsZScsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IG1lc3NhZ2VzIH0pLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQVBJIGVycm9yOicsIGVycm9yRGF0YSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5kZXRhaWxzIHx8ICdGYWlsZWQgdG8gZ2VuZXJhdGUgdGl0bGUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyB0aXRsZSB9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICAvLyDQntCx0L3QvtCy0LvRj9C10Lwg0L3QsNC30LLQsNC90LjQtSDRgSDRjdGE0YTQtdC60YLQvtC8INC/0LXRh9Cw0YLQsNC90LjRj1xuICAgICAgICAgICAgdXBkYXRlU2Vzc2lvblRpdGxlKHNlc3Npb25JZCwgdGl0bGUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyB0aXRsZTonLCBlcnJvcik7XG4gICAgICAgICAgICAvLyDQkiDRgdC70YPRh9Cw0LUg0L7RiNC40LHQutC4INGB0L3QuNC80LDQtdC8INGE0LvQsNCzINCz0LXQvdC10YDQsNGG0LjQuFxuICAgICAgICAgICAgc2V0U2Vzc2lvbnMocHJldiA9PiBwcmV2Lm1hcChzZXNzaW9uID0+XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5pZCA9PT0gc2Vzc2lvbklkXG4gICAgICAgICAgICAgICAgICAgID8geyAuLi5zZXNzaW9uLCBpc0dlbmVyYXRpbmdUaXRsZTogZmFsc2UgfVxuICAgICAgICAgICAgICAgICAgICA6IHNlc3Npb25cbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8g0J7QsdC90L7QstC70LXQvdC40LUg0L3QsNC30LLQsNC90LjRjyDRgdC10YHRgdC40Lgg0YEg0Y3RhNGE0LXQutGC0L7QvCDQv9C10YfQsNGC0LDQvdC40Y9cbiAgICBjb25zdCB1cGRhdGVTZXNzaW9uVGl0bGUgPSB1c2VDYWxsYmFjaygoc2Vzc2lvbklkOiBzdHJpbmcsIG5ld1RpdGxlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgc2V0U2Vzc2lvbnMocHJldiA9PiBwcmV2Lm1hcChzZXNzaW9uID0+XG4gICAgICAgICAgICBzZXNzaW9uLmlkID09PSBzZXNzaW9uSWRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc2Vzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG5ld1RpdGxlLFxuICAgICAgICAgICAgICAgICAgICBpc0dlbmVyYXRpbmdUaXRsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlR2VuZXJhdGVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogc2Vzc2lvblxuICAgICAgICApKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyDQo9C00LDQu9C10L3QuNC1INGB0LXRgdGB0LjQuFxuICAgIGNvbnN0IGRlbGV0ZVNlc3Npb24gPSB1c2VDYWxsYmFjaygoc2Vzc2lvbklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgc2V0U2Vzc2lvbnMocHJldiA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHByZXYuZmlsdGVyKHMgPT4gcy5pZCAhPT0gc2Vzc2lvbklkKTtcblxuICAgICAgICAgICAgLy8g0JXRgdC70Lgg0YPQtNCw0LvRj9C10Lwg0LDQutGC0LjQstC90YPRjiDRgdC10YHRgdC40Y4sINC/0LXRgNC10LrQu9GO0YfQsNC10LzRgdGPINC90LAg0L/QtdGA0LLRg9GOINC40Lcg0L7RgdGC0LDQstGI0LjRhdGB0Y9cbiAgICAgICAgICAgIGlmIChzZXNzaW9uSWQgPT09IGFjdGl2ZVNlc3Npb25JZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRBY3RpdmUgPSBmaWx0ZXJlZFswXT8uaWQgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVTZXNzaW9uSWQobmV4dEFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKEFDVElWRV9TRVNTSU9OX0tFWSwgbmV4dEFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKEFDVElWRV9TRVNTSU9OX0tFWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgICAgIH0pO1xuICAgIH0sIFthY3RpdmVTZXNzaW9uSWRdKTtcblxuICAgIC8vINCj0YHRgtCw0L3QvtCy0LrQsCDQsNC60YLQuNCy0L3QvtC5INGB0LXRgdGB0LjQuFxuICAgIGNvbnN0IHNldEFjdGl2ZVNlc3Npb24gPSB1c2VDYWxsYmFjaygoc2Vzc2lvbklkOiBzdHJpbmcgfCBudWxsKSA9PiB7XG4gICAgICAgIHNldEFjdGl2ZVNlc3Npb25JZChzZXNzaW9uSWQpO1xuICAgICAgICBpZiAoc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oQUNUSVZFX1NFU1NJT05fS0VZLCBzZXNzaW9uSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKEFDVElWRV9TRVNTSU9OX0tFWSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICAvLyDQn9C+0LvRg9GH0LXQvdC40LUg0LDQutGC0LjQstC90L7QuSDRgdC10YHRgdC40LhcbiAgICBjb25zdCBhY3RpdmVTZXNzaW9uID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBzZXNzaW9ucy5maW5kKHMgPT4gcy5pZCA9PT0gYWN0aXZlU2Vzc2lvbklkKSB8fCBudWxsO1xuICAgIH0sIFtzZXNzaW9ucywgYWN0aXZlU2Vzc2lvbklkXSk7XG5cbiAgICAvLyDQk9GA0YPQv9C/0LjRgNC+0LLQutCwINGB0LXRgdGB0LjQuSDQv9C+INC00LDRgtC1XG4gICAgY29uc3QgZ3JvdXBlZFNlc3Npb25zID0gdXNlTWVtbygoKTogR3JvdXBlZFNlc3Npb25zID0+IHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZShub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIG5vdy5nZXREYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgeWVzdGVyZGF5ID0gdG9kYXkgLSAyNCAqIDYwICogNjAgKiAxMDAwO1xuICAgICAgICBjb25zdCB3ZWVrQWdvID0gdG9kYXkgLSA3ICogMjQgKiA2MCAqIDYwICogMTAwMDtcblxuICAgICAgICBjb25zdCBncm91cHM6IEdyb3VwZWRTZXNzaW9ucyA9IHtcbiAgICAgICAgICAgIHRvZGF5OiBbXSxcbiAgICAgICAgICAgIHllc3RlcmRheTogW10sXG4gICAgICAgICAgICB0aGlzV2VlazogW10sXG4gICAgICAgICAgICBvbGRlcjogW10sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8g0KHQvtGA0YLQuNGA0YPQtdC8INC/0L4g0LTQsNGC0LUg0L7QsdC90L7QstC70LXQvdC40Y8gKNC90L7QstGL0LUg0YHQstC10YDRhdGDKVxuICAgICAgICBjb25zdCBzb3J0ZWQgPSBbLi4uc2Vzc2lvbnNdLnNvcnQoKGEsIGIpID0+IGIudXBkYXRlZEF0IC0gYS51cGRhdGVkQXQpO1xuXG4gICAgICAgIHNvcnRlZC5mb3JFYWNoKHNlc3Npb24gPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkRhdGUgPSBzZXNzaW9uLnVwZGF0ZWRBdDtcblxuICAgICAgICAgICAgaWYgKHNlc3Npb25EYXRlID49IHRvZGF5KSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzLnRvZGF5LnB1c2goc2Vzc2lvbik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlc3Npb25EYXRlID49IHllc3RlcmRheSkge1xuICAgICAgICAgICAgICAgIGdyb3Vwcy55ZXN0ZXJkYXkucHVzaChzZXNzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2Vzc2lvbkRhdGUgPj0gd2Vla0Fnbykge1xuICAgICAgICAgICAgICAgIGdyb3Vwcy50aGlzV2Vlay5wdXNoKHNlc3Npb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncm91cHMub2xkZXIucHVzaChzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9LCBbc2Vzc2lvbnNdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHNlc3Npb25zLFxuICAgICAgICBhY3RpdmVTZXNzaW9uLFxuICAgICAgICBhY3RpdmVTZXNzaW9uSWQsXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgY3JlYXRlU2Vzc2lvbixcbiAgICAgICAgdXBkYXRlU2Vzc2lvbixcbiAgICAgICAgZGVsZXRlU2Vzc2lvbixcbiAgICAgICAgc2V0QWN0aXZlU2Vzc2lvbixcbiAgICAgICAgZ3JvdXBlZFNlc3Npb25zLFxuICAgICAgICBnZW5lcmF0ZVRpdGxlLFxuICAgIH07XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJTRVNTSU9OU19TVE9SQUdFX0tFWSIsIkFDVElWRV9TRVNTSU9OX0tFWSIsInVzZUNoYXRTZXNzaW9ucyIsInNlc3Npb25zIiwic2V0U2Vzc2lvbnMiLCJhY3RpdmVTZXNzaW9uSWQiLCJzZXRBY3RpdmVTZXNzaW9uSWQiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJzdG9yZWRTZXNzaW9ucyIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzdG9yZWRBY3RpdmVJZCIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiY29uc29sZSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJjcmVhdGVTZXNzaW9uIiwibmV3U2Vzc2lvbiIsImlkIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsInRpdGxlIiwibWVzc2FnZXMiLCJjcmVhdGVkQXQiLCJEYXRlIiwibm93IiwidXBkYXRlZEF0IiwicHJldiIsInVwZGF0ZVNlc3Npb24iLCJzZXNzaW9uSWQiLCJtYXAiLCJzZXNzaW9uIiwibGVuZ3RoIiwiZmlyc3RVc2VyTWVzc2FnZSIsImZpbmQiLCJtIiwicm9sZSIsInRleHQiLCJzbGljZSIsImdlbmVyYXRlVGl0bGUiLCJpc0dlbmVyYXRpbmdUaXRsZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsIkVycm9yIiwiZGV0YWlscyIsInVwZGF0ZVNlc3Npb25UaXRsZSIsIm5ld1RpdGxlIiwidGl0bGVHZW5lcmF0ZWQiLCJkZWxldGVTZXNzaW9uIiwiZmlsdGVyZWQiLCJmaWx0ZXIiLCJzIiwibmV4dEFjdGl2ZSIsInJlbW92ZUl0ZW0iLCJzZXRBY3RpdmVTZXNzaW9uIiwiYWN0aXZlU2Vzc2lvbiIsImdyb3VwZWRTZXNzaW9ucyIsInRvZGF5IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJnZXRUaW1lIiwieWVzdGVyZGF5Iiwid2Vla0FnbyIsImdyb3VwcyIsInRoaXNXZWVrIiwib2xkZXIiLCJzb3J0ZWQiLCJzb3J0IiwiYSIsImIiLCJmb3JFYWNoIiwic2Vzc2lvbkRhdGUiLCJwdXNoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useChatSessions.ts\n"));

/***/ })

});