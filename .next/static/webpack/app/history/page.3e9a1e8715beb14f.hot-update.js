"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/history/page",{

/***/ "(app-pages-browser)/./hooks/useChatSessions.ts":
/*!**********************************!*\
  !*** ./hooks/useChatSessions.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChatSessions: () => (/* binding */ useChatSessions)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useChatSessions auto */ \nconst SESSIONS_STORAGE_KEY = 'lucra-ai-sessions';\nconst ACTIVE_SESSION_KEY = 'lucra-ai-active-session';\nfunction useChatSessions() {\n    const [sessions, setSessions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [activeSessionId, setActiveSessionId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    // Загрузка сессий из localStorage\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChatSessions.useEffect\": ()=>{\n            try {\n                const storedSessions = window.localStorage.getItem(SESSIONS_STORAGE_KEY);\n                const storedActiveId = window.localStorage.getItem(ACTIVE_SESSION_KEY);\n                if (storedSessions) {\n                    setSessions(JSON.parse(storedSessions));\n                }\n                if (storedActiveId) {\n                    setActiveSessionId(storedActiveId);\n                }\n            } catch (error) {\n                console.error('Error loading sessions:', error);\n            }\n            setIsLoading(false);\n        }\n    }[\"useChatSessions.useEffect\"], []);\n    // Сохранение в localStorage при изменении\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChatSessions.useEffect\": ()=>{\n            if (!isLoading) {\n                try {\n                    window.localStorage.setItem(SESSIONS_STORAGE_KEY, JSON.stringify(sessions));\n                } catch (error) {\n                    console.error('Error saving sessions:', error);\n                }\n            }\n        }\n    }[\"useChatSessions.useEffect\"], [\n        sessions,\n        isLoading\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChatSessions.useEffect\": ()=>{\n            if (!isLoading && activeSessionId) {\n                try {\n                    window.localStorage.setItem(ACTIVE_SESSION_KEY, activeSessionId);\n                } catch (error) {\n                    console.error('Error saving active session:', error);\n                }\n            }\n        }\n    }[\"useChatSessions.useEffect\"], [\n        activeSessionId,\n        isLoading\n    ]);\n    // Создание новой сессии\n    const createSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChatSessions.useCallback[createSession]\": ()=>{\n            const newSession = {\n                id: crypto.randomUUID(),\n                title: 'New Chat',\n                messages: [],\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            };\n            setSessions({\n                \"useChatSessions.useCallback[createSession]\": (prev)=>[\n                        newSession,\n                        ...prev\n                    ]\n            }[\"useChatSessions.useCallback[createSession]\"]);\n            setActiveSessionId(newSession.id);\n            return newSession;\n        }\n    }[\"useChatSessions.useCallback[createSession]\"], []);\n    // Обновление сессии (добавление сообщений)\n    const updateSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChatSessions.useCallback[updateSession]\": (sessionId, messages)=>{\n            setSessions({\n                \"useChatSessions.useCallback[updateSession]\": (prev)=>prev.map({\n                        \"useChatSessions.useCallback[updateSession]\": (session)=>{\n                            if (session.id === sessionId) {\n                                // Генерируем название из первого сообщения пользователя\n                                let title = session.title;\n                                if (title === 'New Chat' && messages.length > 0) {\n                                    const firstUserMessage = messages.find({\n                                        \"useChatSessions.useCallback[updateSession].firstUserMessage\": (m)=>m.role === 'user'\n                                    }[\"useChatSessions.useCallback[updateSession].firstUserMessage\"]);\n                                    if (firstUserMessage) {\n                                        title = firstUserMessage.text.slice(0, 50);\n                                        if (firstUserMessage.text.length > 50) {\n                                            title += '...';\n                                        }\n                                    }\n                                }\n                                return {\n                                    ...session,\n                                    title,\n                                    messages,\n                                    updatedAt: Date.now()\n                                };\n                            }\n                            return session;\n                        }\n                    }[\"useChatSessions.useCallback[updateSession]\"])\n            }[\"useChatSessions.useCallback[updateSession]\"]);\n        }\n    }[\"useChatSessions.useCallback[updateSession]\"], []);\n    // Удаление сессии\n    const deleteSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChatSessions.useCallback[deleteSession]\": (sessionId)=>{\n            setSessions({\n                \"useChatSessions.useCallback[deleteSession]\": (prev)=>{\n                    const filtered = prev.filter({\n                        \"useChatSessions.useCallback[deleteSession].filtered\": (s)=>s.id !== sessionId\n                    }[\"useChatSessions.useCallback[deleteSession].filtered\"]);\n                    // Если удаляем активную сессию, переключаемся на первую из оставшихся\n                    if (sessionId === activeSessionId) {\n                        var _filtered_;\n                        const nextActive = ((_filtered_ = filtered[0]) === null || _filtered_ === void 0 ? void 0 : _filtered_.id) || null;\n                        setActiveSessionId(nextActive);\n                        if (nextActive) {\n                            window.localStorage.setItem(ACTIVE_SESSION_KEY, nextActive);\n                        } else {\n                            window.localStorage.removeItem(ACTIVE_SESSION_KEY);\n                        }\n                    }\n                    return filtered;\n                }\n            }[\"useChatSessions.useCallback[deleteSession]\"]);\n        }\n    }[\"useChatSessions.useCallback[deleteSession]\"], [\n        activeSessionId\n    ]);\n    // Установка активной сессии\n    const setActiveSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChatSessions.useCallback[setActiveSession]\": (sessionId)=>{\n            setActiveSessionId(sessionId);\n            if (sessionId) {\n                window.localStorage.setItem(ACTIVE_SESSION_KEY, sessionId);\n            } else {\n                window.localStorage.removeItem(ACTIVE_SESSION_KEY);\n            }\n        }\n    }[\"useChatSessions.useCallback[setActiveSession]\"], []);\n    // Получение активной сессии\n    const activeSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useChatSessions.useMemo[activeSession]\": ()=>{\n            return sessions.find({\n                \"useChatSessions.useMemo[activeSession]\": (s)=>s.id === activeSessionId\n            }[\"useChatSessions.useMemo[activeSession]\"]) || null;\n        }\n    }[\"useChatSessions.useMemo[activeSession]\"], [\n        sessions,\n        activeSessionId\n    ]);\n    // Группировка сессий по дате\n    const groupedSessions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useChatSessions.useMemo[groupedSessions]\": ()=>{\n            const now = new Date();\n            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();\n            const yesterday = today - 24 * 60 * 60 * 1000;\n            const weekAgo = today - 7 * 24 * 60 * 60 * 1000;\n            const groups = {\n                today: [],\n                yesterday: [],\n                thisWeek: [],\n                older: []\n            };\n            // Сортируем по дате обновления (новые сверху)\n            const sorted = [\n                ...sessions\n            ].sort({\n                \"useChatSessions.useMemo[groupedSessions].sorted\": (a, b)=>b.updatedAt - a.updatedAt\n            }[\"useChatSessions.useMemo[groupedSessions].sorted\"]);\n            sorted.forEach({\n                \"useChatSessions.useMemo[groupedSessions]\": (session)=>{\n                    const sessionDate = session.updatedAt;\n                    if (sessionDate >= today) {\n                        groups.today.push(session);\n                    } else if (sessionDate >= yesterday) {\n                        groups.yesterday.push(session);\n                    } else if (sessionDate >= weekAgo) {\n                        groups.thisWeek.push(session);\n                    } else {\n                        groups.older.push(session);\n                    }\n                }\n            }[\"useChatSessions.useMemo[groupedSessions]\"]);\n            return groups;\n        }\n    }[\"useChatSessions.useMemo[groupedSessions]\"], [\n        sessions\n    ]);\n    return {\n        sessions,\n        activeSession,\n        activeSessionId,\n        isLoading,\n        createSession,\n        updateSession,\n        deleteSession,\n        setActiveSession,\n        groupedSessions\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUNoYXRTZXNzaW9ucy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7cUVBRWtFO0FBR2xFLE1BQU1JLHVCQUF1QjtBQUM3QixNQUFNQyxxQkFBcUI7QUFVcEIsU0FBU0M7SUFDWixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR1IsK0NBQVFBLENBQWdCLEVBQUU7SUFDMUQsTUFBTSxDQUFDUyxpQkFBaUJDLG1CQUFtQixHQUFHViwrQ0FBUUEsQ0FBZ0I7SUFDdEUsTUFBTSxDQUFDVyxXQUFXQyxhQUFhLEdBQUdaLCtDQUFRQSxDQUFDO0lBRTNDLGtDQUFrQztJQUNsQ0MsZ0RBQVNBO3FDQUFDO1lBQ04sSUFBSTtnQkFDQSxNQUFNWSxpQkFBaUJDLE9BQU9DLFlBQVksQ0FBQ0MsT0FBTyxDQUFDWjtnQkFDbkQsTUFBTWEsaUJBQWlCSCxPQUFPQyxZQUFZLENBQUNDLE9BQU8sQ0FBQ1g7Z0JBRW5ELElBQUlRLGdCQUFnQjtvQkFDaEJMLFlBQVlVLEtBQUtDLEtBQUssQ0FBQ047Z0JBQzNCO2dCQUNBLElBQUlJLGdCQUFnQjtvQkFDaEJQLG1CQUFtQk87Z0JBQ3ZCO1lBQ0osRUFBRSxPQUFPRyxPQUFPO2dCQUNaQyxRQUFRRCxLQUFLLENBQUMsMkJBQTJCQTtZQUM3QztZQUNBUixhQUFhO1FBQ2pCO29DQUFHLEVBQUU7SUFFTCwwQ0FBMEM7SUFDMUNYLGdEQUFTQTtxQ0FBQztZQUNOLElBQUksQ0FBQ1UsV0FBVztnQkFDWixJQUFJO29CQUNBRyxPQUFPQyxZQUFZLENBQUNPLE9BQU8sQ0FBQ2xCLHNCQUFzQmMsS0FBS0ssU0FBUyxDQUFDaEI7Z0JBQ3JFLEVBQUUsT0FBT2EsT0FBTztvQkFDWkMsUUFBUUQsS0FBSyxDQUFDLDBCQUEwQkE7Z0JBQzVDO1lBQ0o7UUFDSjtvQ0FBRztRQUFDYjtRQUFVSTtLQUFVO0lBRXhCVixnREFBU0E7cUNBQUM7WUFDTixJQUFJLENBQUNVLGFBQWFGLGlCQUFpQjtnQkFDL0IsSUFBSTtv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Zi9Xb3JrL01WUC9MdWNyYUFJL2hvb2tzL3VzZUNoYXRTZXNzaW9ucy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ2hhdFNlc3Npb24sIENoYXRNZXNzYWdlIH0gZnJvbSAnQC90eXBlcyc7XG5cbmNvbnN0IFNFU1NJT05TX1NUT1JBR0VfS0VZID0gJ2x1Y3JhLWFpLXNlc3Npb25zJztcbmNvbnN0IEFDVElWRV9TRVNTSU9OX0tFWSA9ICdsdWNyYS1haS1hY3RpdmUtc2Vzc2lvbic7XG5cbi8vINCT0YDRg9C/0L/RiyDQv9C+INC00LDRgtC1XG5leHBvcnQgaW50ZXJmYWNlIEdyb3VwZWRTZXNzaW9ucyB7XG4gICAgdG9kYXk6IENoYXRTZXNzaW9uW107XG4gICAgeWVzdGVyZGF5OiBDaGF0U2Vzc2lvbltdO1xuICAgIHRoaXNXZWVrOiBDaGF0U2Vzc2lvbltdO1xuICAgIG9sZGVyOiBDaGF0U2Vzc2lvbltdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hhdFNlc3Npb25zKCkge1xuICAgIGNvbnN0IFtzZXNzaW9ucywgc2V0U2Vzc2lvbnNdID0gdXNlU3RhdGU8Q2hhdFNlc3Npb25bXT4oW10pO1xuICAgIGNvbnN0IFthY3RpdmVTZXNzaW9uSWQsIHNldEFjdGl2ZVNlc3Npb25JZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG5cbiAgICAvLyDQl9Cw0LPRgNGD0LfQutCwINGB0LXRgdGB0LjQuSDQuNC3IGxvY2FsU3RvcmFnZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWRTZXNzaW9ucyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShTRVNTSU9OU19TVE9SQUdFX0tFWSk7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWRBY3RpdmVJZCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShBQ1RJVkVfU0VTU0lPTl9LRVkpO1xuXG4gICAgICAgICAgICBpZiAoc3RvcmVkU2Vzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBzZXRTZXNzaW9ucyhKU09OLnBhcnNlKHN0b3JlZFNlc3Npb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RvcmVkQWN0aXZlSWQpIHtcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVTZXNzaW9uSWQoc3RvcmVkQWN0aXZlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBzZXNzaW9uczonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyDQodC+0YXRgNCw0L3QtdC90LjQtSDQsiBsb2NhbFN0b3JhZ2Ug0L/RgNC4INC40LfQvNC10L3QtdC90LjQuFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShTRVNTSU9OU19TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbnMpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIHNlc3Npb25zOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtzZXNzaW9ucywgaXNMb2FkaW5nXSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWlzTG9hZGluZyAmJiBhY3RpdmVTZXNzaW9uSWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKEFDVElWRV9TRVNTSU9OX0tFWSwgYWN0aXZlU2Vzc2lvbklkKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIGFjdGl2ZSBzZXNzaW9uOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFthY3RpdmVTZXNzaW9uSWQsIGlzTG9hZGluZ10pO1xuXG4gICAgLy8g0KHQvtC30LTQsNC90LjQtSDQvdC+0LLQvtC5INGB0LXRgdGB0LjQuFxuICAgIGNvbnN0IGNyZWF0ZVNlc3Npb24gPSB1c2VDYWxsYmFjaygoKTogQ2hhdFNlc3Npb24gPT4ge1xuICAgICAgICBjb25zdCBuZXdTZXNzaW9uOiBDaGF0U2Vzc2lvbiA9IHtcbiAgICAgICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICAgICAgdGl0bGU6ICdOZXcgQ2hhdCcsXG4gICAgICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0U2Vzc2lvbnMocHJldiA9PiBbbmV3U2Vzc2lvbiwgLi4ucHJldl0pO1xuICAgICAgICBzZXRBY3RpdmVTZXNzaW9uSWQobmV3U2Vzc2lvbi5pZCk7XG5cbiAgICAgICAgcmV0dXJuIG5ld1Nlc3Npb247XG4gICAgfSwgW10pO1xuXG4gICAgLy8g0J7QsdC90L7QstC70LXQvdC40LUg0YHQtdGB0YHQuNC4ICjQtNC+0LHQsNCy0LvQtdC90LjQtSDRgdC+0L7QsdGJ0LXQvdC40LkpXG4gICAgY29uc3QgdXBkYXRlU2Vzc2lvbiA9IHVzZUNhbGxiYWNrKChzZXNzaW9uSWQ6IHN0cmluZywgbWVzc2FnZXM6IENoYXRNZXNzYWdlW10pID0+IHtcbiAgICAgICAgc2V0U2Vzc2lvbnMocHJldiA9PiBwcmV2Lm1hcChzZXNzaW9uID0+IHtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uLmlkID09PSBzZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICAvLyDQk9C10L3QtdGA0LjRgNGD0LXQvCDQvdCw0LfQstCw0L3QuNC1INC40Lcg0L/QtdGA0LLQvtCz0L4g0YHQvtC+0LHRidC10L3QuNGPINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRj1xuICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IHNlc3Npb24udGl0bGU7XG4gICAgICAgICAgICAgICAgaWYgKHRpdGxlID09PSAnTmV3IENoYXQnICYmIG1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RVc2VyTWVzc2FnZSA9IG1lc3NhZ2VzLmZpbmQobSA9PiBtLnJvbGUgPT09ICd1c2VyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFVzZXJNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IGZpcnN0VXNlck1lc3NhZ2UudGV4dC5zbGljZSgwLCA1MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RVc2VyTWVzc2FnZS50ZXh0Lmxlbmd0aCA+IDUwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgKz0gJy4uLic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5zZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgICAgIH0pKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyDQo9C00LDQu9C10L3QuNC1INGB0LXRgdGB0LjQuFxuICAgIGNvbnN0IGRlbGV0ZVNlc3Npb24gPSB1c2VDYWxsYmFjaygoc2Vzc2lvbklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgc2V0U2Vzc2lvbnMocHJldiA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHByZXYuZmlsdGVyKHMgPT4gcy5pZCAhPT0gc2Vzc2lvbklkKTtcblxuICAgICAgICAgICAgLy8g0JXRgdC70Lgg0YPQtNCw0LvRj9C10Lwg0LDQutGC0LjQstC90YPRjiDRgdC10YHRgdC40Y4sINC/0LXRgNC10LrQu9GO0YfQsNC10LzRgdGPINC90LAg0L/QtdGA0LLRg9GOINC40Lcg0L7RgdGC0LDQstGI0LjRhdGB0Y9cbiAgICAgICAgICAgIGlmIChzZXNzaW9uSWQgPT09IGFjdGl2ZVNlc3Npb25JZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRBY3RpdmUgPSBmaWx0ZXJlZFswXT8uaWQgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVTZXNzaW9uSWQobmV4dEFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKEFDVElWRV9TRVNTSU9OX0tFWSwgbmV4dEFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKEFDVElWRV9TRVNTSU9OX0tFWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgICAgIH0pO1xuICAgIH0sIFthY3RpdmVTZXNzaW9uSWRdKTtcblxuICAgIC8vINCj0YHRgtCw0L3QvtCy0LrQsCDQsNC60YLQuNCy0L3QvtC5INGB0LXRgdGB0LjQuFxuICAgIGNvbnN0IHNldEFjdGl2ZVNlc3Npb24gPSB1c2VDYWxsYmFjaygoc2Vzc2lvbklkOiBzdHJpbmcgfCBudWxsKSA9PiB7XG4gICAgICAgIHNldEFjdGl2ZVNlc3Npb25JZChzZXNzaW9uSWQpO1xuICAgICAgICBpZiAoc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oQUNUSVZFX1NFU1NJT05fS0VZLCBzZXNzaW9uSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKEFDVElWRV9TRVNTSU9OX0tFWSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICAvLyDQn9C+0LvRg9GH0LXQvdC40LUg0LDQutGC0LjQstC90L7QuSDRgdC10YHRgdC40LhcbiAgICBjb25zdCBhY3RpdmVTZXNzaW9uID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBzZXNzaW9ucy5maW5kKHMgPT4gcy5pZCA9PT0gYWN0aXZlU2Vzc2lvbklkKSB8fCBudWxsO1xuICAgIH0sIFtzZXNzaW9ucywgYWN0aXZlU2Vzc2lvbklkXSk7XG5cbiAgICAvLyDQk9GA0YPQv9C/0LjRgNC+0LLQutCwINGB0LXRgdGB0LjQuSDQv9C+INC00LDRgtC1XG4gICAgY29uc3QgZ3JvdXBlZFNlc3Npb25zID0gdXNlTWVtbygoKTogR3JvdXBlZFNlc3Npb25zID0+IHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZShub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIG5vdy5nZXREYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgeWVzdGVyZGF5ID0gdG9kYXkgLSAyNCAqIDYwICogNjAgKiAxMDAwO1xuICAgICAgICBjb25zdCB3ZWVrQWdvID0gdG9kYXkgLSA3ICogMjQgKiA2MCAqIDYwICogMTAwMDtcblxuICAgICAgICBjb25zdCBncm91cHM6IEdyb3VwZWRTZXNzaW9ucyA9IHtcbiAgICAgICAgICAgIHRvZGF5OiBbXSxcbiAgICAgICAgICAgIHllc3RlcmRheTogW10sXG4gICAgICAgICAgICB0aGlzV2VlazogW10sXG4gICAgICAgICAgICBvbGRlcjogW10sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8g0KHQvtGA0YLQuNGA0YPQtdC8INC/0L4g0LTQsNGC0LUg0L7QsdC90L7QstC70LXQvdC40Y8gKNC90L7QstGL0LUg0YHQstC10YDRhdGDKVxuICAgICAgICBjb25zdCBzb3J0ZWQgPSBbLi4uc2Vzc2lvbnNdLnNvcnQoKGEsIGIpID0+IGIudXBkYXRlZEF0IC0gYS51cGRhdGVkQXQpO1xuXG4gICAgICAgIHNvcnRlZC5mb3JFYWNoKHNlc3Npb24gPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkRhdGUgPSBzZXNzaW9uLnVwZGF0ZWRBdDtcblxuICAgICAgICAgICAgaWYgKHNlc3Npb25EYXRlID49IHRvZGF5KSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzLnRvZGF5LnB1c2goc2Vzc2lvbik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlc3Npb25EYXRlID49IHllc3RlcmRheSkge1xuICAgICAgICAgICAgICAgIGdyb3Vwcy55ZXN0ZXJkYXkucHVzaChzZXNzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2Vzc2lvbkRhdGUgPj0gd2Vla0Fnbykge1xuICAgICAgICAgICAgICAgIGdyb3Vwcy50aGlzV2Vlay5wdXNoKHNlc3Npb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncm91cHMub2xkZXIucHVzaChzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9LCBbc2Vzc2lvbnNdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHNlc3Npb25zLFxuICAgICAgICBhY3RpdmVTZXNzaW9uLFxuICAgICAgICBhY3RpdmVTZXNzaW9uSWQsXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgY3JlYXRlU2Vzc2lvbixcbiAgICAgICAgdXBkYXRlU2Vzc2lvbixcbiAgICAgICAgZGVsZXRlU2Vzc2lvbixcbiAgICAgICAgc2V0QWN0aXZlU2Vzc2lvbixcbiAgICAgICAgZ3JvdXBlZFNlc3Npb25zLFxuICAgIH07XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJTRVNTSU9OU19TVE9SQUdFX0tFWSIsIkFDVElWRV9TRVNTSU9OX0tFWSIsInVzZUNoYXRTZXNzaW9ucyIsInNlc3Npb25zIiwic2V0U2Vzc2lvbnMiLCJhY3RpdmVTZXNzaW9uSWQiLCJzZXRBY3RpdmVTZXNzaW9uSWQiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJzdG9yZWRTZXNzaW9ucyIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzdG9yZWRBY3RpdmVJZCIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiY29uc29sZSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJjcmVhdGVTZXNzaW9uIiwibmV3U2Vzc2lvbiIsImlkIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsInRpdGxlIiwibWVzc2FnZXMiLCJjcmVhdGVkQXQiLCJEYXRlIiwibm93IiwidXBkYXRlZEF0IiwicHJldiIsInVwZGF0ZVNlc3Npb24iLCJzZXNzaW9uSWQiLCJtYXAiLCJzZXNzaW9uIiwibGVuZ3RoIiwiZmlyc3RVc2VyTWVzc2FnZSIsImZpbmQiLCJtIiwicm9sZSIsInRleHQiLCJzbGljZSIsImRlbGV0ZVNlc3Npb24iLCJmaWx0ZXJlZCIsImZpbHRlciIsInMiLCJuZXh0QWN0aXZlIiwicmVtb3ZlSXRlbSIsInNldEFjdGl2ZVNlc3Npb24iLCJhY3RpdmVTZXNzaW9uIiwiZ3JvdXBlZFNlc3Npb25zIiwidG9kYXkiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldFRpbWUiLCJ5ZXN0ZXJkYXkiLCJ3ZWVrQWdvIiwiZ3JvdXBzIiwidGhpc1dlZWsiLCJvbGRlciIsInNvcnRlZCIsInNvcnQiLCJhIiwiYiIsImZvckVhY2giLCJzZXNzaW9uRGF0ZSIsInB1c2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useChatSessions.ts\n"));

/***/ })

});